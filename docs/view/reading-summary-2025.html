<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Reading Summary 2025</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Ubuntu font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@300;400;500;700&display=swap" rel="stylesheet">

  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0;
      background: #0b0b0f;
      color: #eaeaf2;
      font-family: 'Ubuntu', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    header {
      max-width: 1100px;
      margin: 0 auto;
      padding: 14px 16px 10px 16px;
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      font-size: 14px;
    }

    .crumbs {
      display: flex;
      gap: 10px;
      align-items: baseline;
      flex-wrap: wrap;
    }

    a {
      color: inherit;
      opacity: 0.88;
      text-decoration: none;
    }
    a:hover { opacity: 1; text-decoration: underline; }

    .wrap {
      max-width: 1100px;
      margin: 0 auto;
      padding: 0 16px 24px 16px;
    }

    .panel {
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      overflow: hidden;
      background: rgba(255,255,255,0.03);
    }

    /* Toolbar */
    .toolbar {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.02);
      flex-wrap: wrap;
    }

    .btnRow {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    button, .btn {
      appearance: none;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.05);
      color: inherit;
      font-family: inherit;
      font-size: 13px;
      padding: 7px 10px;
      border-radius: 12px;
      cursor: pointer;
      opacity: 0.95;
    }
    button:hover, .btn:hover { opacity: 1; border-color: rgba(255,255,255,0.25); }
    button:active { transform: translateY(1px); }

    .hint {
      font-size: 12px;
      opacity: 0.70;
      line-height: 1.25;
    }

    /* Viewer */
  .viewer {
    position: relative;
    width: 100%;
    height: min(78vh, 900px);
    background: #0f0f14;
    overflow: auto;
    touch-action: pan-x pan-y;
    cursor: zoom-in;
  }

  .stage {
    position: relative;
    transform-origin: 0 0;
    width: fit-content;
    height: fit-content;
  }

/* IMPORTANT: start by fitting the image visually, not at native size */
  img {
    display: block;
    max-width: 100%;
    height: auto;
    user-select: none;
    -webkit-user-drag: none;
  }


    /* Footer */
    .footer {
      padding: 10px 12px;
      font-size: 12px;
      opacity: 0.78;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      border-top: 1px solid rgba(255,255,255,0.08);
    }

    code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }
  </style>
</head>
<body>
  <header>
    <div class="crumbs">
      <a href="../index.html">← index</a>
      <span style="opacity:0.65;">/</span>
      <span>Reading Summary 2025</span>
    </div>
    <div class="hint">
      Tip: click/tap to zoom, scroll/drag to pan when zoomed
    </div>
  </header>

  <div class="wrap">
    <div class="panel">

      <div class="toolbar">
        <div class="btnRow">
          <button id="zoomOut" type="button">−</button>
          <button id="zoomIn" type="button">+</button>
          <button id="reset" type="button">Reset</button>
          <span class="hint" id="zoomLabel">100%</span>
        </div>

        <div class="btnRow">
          <!-- Download: uses the file itself, sets a nice filename -->
          <a class="btn" id="downloadBtn" href="../assets/reading-summary-2025.png" download="reading-summary-2025.png">
            Download image
          </a>
        </div>
      </div>

      <div class="viewer" id="viewer">
        <div class="stage" id="stage">
          <img id="img"
               src="../assets/reading-summary-2025.png"
               alt="Reading Summary 2025">
        </div>
      </div>

      <div class="footer">
        <span>File:</span>
        <code>../assets/reading-summary-2025.png</code>
      </div>

    </div>
  </div>

 <script>
  // User zoom (multiplier on top of "fit to viewer")
  const MIN_ZOOM = 1;
  const MAX_ZOOM = 8;
  const STEP = 1.25;

  const viewer = document.getElementById('viewer');
  const stage  = document.getElementById('stage');
  const img    = document.getElementById('img');

  const zoomInBtn  = document.getElementById('zoomIn');
  const zoomOutBtn = document.getElementById('zoomOut');
  const resetBtn   = document.getElementById('reset');
  const zoomLabel  = document.getElementById('zoomLabel');

  let userZoom = 1;     // what you control with buttons
  let fitScale = 1;     // computed so whole image fits initially

  function clamp(n, lo, hi) { return Math.max(lo, Math.min(hi, n)); }

  function computeFitScale() {
    // We want to fit the entire image inside the viewer area.
    // naturalWidth/Height are the true pixel dimensions of the image.
    const vw = viewer.clientWidth;
    const vh = viewer.clientHeight;

    const nw = img.naturalWidth;
    const nh = img.naturalHeight;

    if (!nw || !nh || !vw || !vh) return 1;

    // Fit both directions, choose the limiting dimension.
    const scaleX = vw / nw;
    const scaleY = vh / nh;

    // Don't upscale above 1 by default (keeps things crisp).
    return Math.min(1, scaleX, scaleY);
  }

  function applyScale() {
    const effective = fitScale * userZoom;
    stage.style.transform = `scale(${effective})`;
    zoomLabel.textContent = `${Math.round(userZoom * 100)}%`;
    viewer.style.cursor = userZoom > 1 ? 'grab' : 'zoom-in';
  }

  function centerImage() {
    // After scaling, center the content by scrolling to the middle.
    // stage's bounding box in scaled space is hard to query directly,
    // but we can approximate using natural size * effective scale.
    const effective = fitScale * userZoom;

    const contentW = img.naturalWidth * effective;
    const contentH = img.naturalHeight * effective;

    const targetLeft = Math.max(0, (contentW - viewer.clientWidth) / 2);
    const targetTop  = Math.max(0, (contentH - viewer.clientHeight) / 2);

    viewer.scrollLeft = targetLeft;
    viewer.scrollTop  = targetTop;
  }

  // Keep point under cursor stable while zooming
  function zoomAt(clientX, clientY, newUserZoom) {
    const rect = viewer.getBoundingClientRect();
    const xInViewer = clientX - rect.left;
    const yInViewer = clientY - rect.top;

    const oldEffective = fitScale * userZoom;

    const scrollLeft = viewer.scrollLeft;
    const scrollTop  = viewer.scrollTop;

    const xOnStage = (scrollLeft + xInViewer) / oldEffective;
    const yOnStage = (scrollTop  + yInViewer) / oldEffective;

    userZoom = clamp(newUserZoom, MIN_ZOOM, MAX_ZOOM);
    const newEffective = fitScale * userZoom;

    stage.style.transform = `scale(${newEffective})`;
    zoomLabel.textContent = `${Math.round(userZoom * 100)}%`;
    viewer.style.cursor = userZoom > 1 ? 'grab' : 'zoom-in';

    viewer.scrollLeft = xOnStage * newEffective - xInViewer;
    viewer.scrollTop  = yOnStage * newEffective - yInViewer;
  }

  function resetView() {
    userZoom = 1;
    fitScale = computeFitScale();
    applyScale();
    centerImage();
  }

  // Buttons
  zoomInBtn.addEventListener('click', () => {
    const rect = viewer.getBoundingClientRect();
    zoomAt(rect.left + rect.width/2, rect.top + rect.height/2, userZoom * STEP);
  });

  zoomOutBtn.addEventListener('click', () => {
    const rect = viewer.getBoundingClientRect();
    zoomAt(rect.left + rect.width/2, rect.top + rect.height/2, userZoom / STEP);
  });

  resetBtn.addEventListener('click', resetView);

  // Click/tap toggle
  viewer.addEventListener('click', (e) => {
    if (e.target !== img && e.target !== viewer && e.target !== stage) return;
    if (userZoom === 1) zoomAt(e.clientX, e.clientY, 2);
    else zoomAt(e.clientX, e.clientY, 1);
  });

  // Ctrl+wheel zoom (desktop)
  viewer.addEventListener('wheel', (e) => {
    if (!e.ctrlKey) return;
    e.preventDefault();
    const direction = Math.sign(e.deltaY);
    const factor = direction > 0 ? (1/STEP) : STEP;
    zoomAt(e.clientX, e.clientY, userZoom * factor);
  }, { passive: false });

  // Initialize once the image knows its natural size
  if (img.complete) {
    resetView();
  } else {
    img.addEventListener('load', resetView, { once: true });
  }

  // If the window changes size, recompute fit scale but preserve userZoom
  window.addEventListener('resize', () => {
    const oldFit = fitScale;
    fitScale = computeFitScale();
    // Adjust scroll so view doesn’t jump wildly: re-center is simplest and stable
    applyScale();
    centerImage();
  });
</script>
